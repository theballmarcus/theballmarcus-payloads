#!/usr/bin/env python3
import sys
import re
import argparse
import string
import os
import subprocess
import json
from collections import defaultdict
import pprint

def find_most_probable_character(data):
    # Define safe characters (alphanumeric and common safe symbols)
    SAFE_CHARS = set(
        'abcdefghijklmnopqrstuvwxyz'
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        '0123456789'
        '-_'
    )
    
    pattern_counts = defaultdict(int)
    
    # Count occurrences of each response pattern
    for entry in data:
        pattern = (entry['chars'], entry['words'], entry['lines'])
        pattern_counts[pattern] += 1
    
    if not pattern_counts:
        return {'safe_chars': [], 'special_chars': []}
    
    # Find the most common pattern (majority)
    majority_pattern = max(pattern_counts.items(), key=lambda x: x[1])[0]
    
    # Find entries that differ from majority pattern (successful responses only)
    candidates = []
    for entry in data:
        if entry['code'] < 400:  # Only successful responses
            current_pattern = (entry['chars'], entry['words'], entry['lines'])
            if current_pattern != majority_pattern:
                candidates.append(entry)
    
    # Prepare result dictionary
    result = {
        'safe_chars': [],
        'special_chars': []
    }
    
    if candidates:
        # Calculate deviation score
        majority_chars, majority_words, majority_lines = majority_pattern
        for candidate in candidates:
            deviation = (
                abs(candidate['chars'] - majority_chars) +
                abs(candidate['words'] - majority_words) +
                abs(candidate['lines'] - majority_lines)
            )
            candidate['deviation'] = deviation
        
        # Sort by deviation (highest first)
        candidates.sort(key=lambda x: x['deviation'], reverse=True)
        
        # Get max deviation
        max_deviation = candidates[0]['deviation']
        top_candidates = [c for c in candidates if c['deviation'] == max_deviation]
        
        # Categorize candidates
        for candidate in top_candidates:
            char = candidate['payload']
            if char and char[0] in SAFE_CHARS and len(char) == 1:  # Check if first char is safe
                result['safe_chars'].append({
                    'char': char,
                    'deviation': candidate['deviation'],
                    'details': {
                        'chars': candidate['chars'],
                        'words': candidate['words'],
                        'lines': candidate['lines']
                    }
                })
            else:
                result['special_chars'].append({
                    'char': char,
                    'deviation': candidate['deviation'],
                    'details': {
                        'chars': candidate['chars'],
                        'words': candidate['words'],
                        'lines': candidate['lines']
                    }
                })
    
    return result

def to_ansi_c_quoted_string(s):
    res = []
    i = 0
    while i < len(s):
        c = s[i]

        if c == '\r' and i+1 < len(s) and s[i+1] == '\n':
            res.append('\\x0d\\x0a')
            i += 2
            continue

        if c == '\n':
            res.append('\\x0d\\x0a')
            i += 1
            continue

        # Safe printable ASCII characters except backslash and single quote
        if 32 <= ord(c) <= 126 and c not in ("\\", "'"):
            res.append(c)
        else:
            if c == '\\':
                res.append('\\\\')
            elif c == "'":
                res.append("\\'")
            else:
                res.append(f'\\x{ord(c):02x}')
        i += 1
    return "$'" + ''.join(res) + "'"

def parse_burp_request_file(file_path):
    with open(file_path, 'r') as f:
        lines = f.read().splitlines()

    # Extract method, path, and HTTP version
    request_line = lines[0]
    method, path, _ = request_line.split()

    # Parse headers and body
    headers = {}
    body = ''
    in_body = False
    for line in lines[1:]:
        if line.strip() == '':
            in_body = True
            continue
        if in_body:
            body += line + '\r\n'
        else:
            if ':' in line:
                k, v = line.split(':', 1)
                headers[k.strip()] = v.strip()
    return method, path, headers, body

def build_wfuzz_command(method, path, headers, body, args):
    filters = {
        'hl': args.hl,
        'hh': args.hh,
        'sc': args.sc,
        'hc': args.hc
    }

    wordlist = None
    if args.w:
        wordlist = f'file,{args.w}'
    elif args.r:
        wordlist = f'range,1-{args.r}'
    elif args.guess_word:
        wordlist = 'file,/tmp/printables.txt'
        with open('/tmp/printables.txt', 'w') as f:
            f.write('\n'.join([c for c in string.printable if c.isprintable()]))

    # Identify FUZZ placeholders
    fuzz_locations = []

    if 'FUZZ' in path:
        fuzz_locations.append('path')

    header_fuzz = {}
    for hname, hval in headers.items():
        if 'FUZZ' in hval:
            header_fuzz[hname] = hval
            fuzz_locations.append(f'header:{hname}')

    body_fuzz = None
    if 'FUZZ' in body:
        body_fuzz = body
        fuzz_locations.append('body')

    # Count number of FUZZ occurrences
    fuzz_count = sum([
        path.count('FUZZ'),
        sum(v.count('FUZZ') for v in header_fuzz.values()),
        body.count('FUZZ') if body_fuzz else 0
    ])
        
    payloads = ' -z ' + ' -z '.join([f'{wordlist}'] * fuzz_count)

    cmd = f"wfuzz{payloads} -X {method}"

    if args.v:
        cmd += " -v"

    if filters.get('hl'):
        cmd += f' --hl {filters["hl"]}'
    if filters.get('hh'):
        cmd += f' --hh {filters["hh"]}'
    if filters.get('sc'):
        cmd += f' --sc {filters["sc"]}'
    if filters.get('hc'):
        cmd += f' --hc {filters["hc"]}'

    if args.ss:
        cmd += f' --ss "{args.ss}"'

    if args.hs:
        cmd += f' --hs "{args.hs}"'

    for hname, hval in headers.items():
        if 'FUZZ' in hval:
            cmd += f' -H "{hname}: {hval}"'
        else:
            cmd += f' -H "{hname}: {hval}"'

    if args.guess_word:
        cmd += ' -o json'

    if body:
        safe_body = to_ansi_c_quoted_string(body)
        cmd += f' -d {safe_body}'

    full_url = args.base_url.rstrip("/") + path
    cmd += f' "{full_url}"'

    return cmd

def guess_string(wfuzz_cmd, curGuess=""):
    while True:                    
        print("\nðŸ”¥ Executing command...")
        print()
        cur_wfuzz_cmd = wfuzz_cmd.replace('FUZZ', f'{curGuess}FUZZ')

        process = subprocess.Popen(
            cur_wfuzz_cmd, shell=True, executable='/bin/bash',
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
        )

        for line in process.stdout:
            if line.strip() == "":
                continue
            try:
                resp = json.loads(line)
                chars = find_most_probable_character(resp)
                print("Safe characters:", len(chars['safe_chars']))
                if len(chars['safe_chars']) == 1:
                    found_char = chars['safe_chars'][0]['char']
                    curGuess += found_char
                    print(f'Found char {found_char} at index {len(curGuess) - 1}. Current password: {curGuess}')
                else:
                    print('Manual inspecting required.')
                    pprint.pprint(chars)
                    return curGuess
                
            except Exception as e:
                print(e)
            
        process.wait()
    
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Convert Burp request to wfuzz command.")
    parser.add_argument("request_file", help="Burp-style HTTP request file")
    parser.add_argument("base_url", help="Base URL like https://example.com")

    # Optional filters
    parser.add_argument("-r", type=int, help="Wordlist file for fuzzing")
    parser.add_argument("-w", type=str, help="Wordlist for fuzzing")
    parser.add_argument("--hl", type=int, help="Hide responses with the given length")
    parser.add_argument("--hh", type=int, help="Show only responses with the given length")
    parser.add_argument("--sc", type=str, help="Show only responses with status code(s), e.g., 200,301")
    parser.add_argument("--hc", type=str, help="Hide responses with status code(s), e.g., 404")

    parser.add_argument("--ss", type=str, help="String that Wfuzz should look for in the response to consider it a success")
    parser.add_argument("--hs", type=str, help="String that Wfuzz should look for in the response to consider it a failure")

    parser.add_argument("--dr", action="store_true", help="Only print the command, dont run.")
    parser.add_argument("-v", action="store_true", help="Only print the command, dont run.")
    parser.add_argument("--guess_word", action="store_true", help="Guesses word character by character")

    args = parser.parse_args()

    method, path, headers, body = parse_burp_request_file(args.request_file)
    
    wfuzz_cmd = build_wfuzz_command(method, path, headers, body, args)

    print("\nðŸ”¥ Generated wfuzz command:\n")
    print(wfuzz_cmd)

    if args.dr:
        print("\nðŸ”¥ Dry run mode enabled, command not executed.")
    else:

        if args.guess_word:
            if 'FIZZ' in wfuzz_cmd:
                results = []
                i = 0
                while True:
                    cur_wfuzz_cmd = wfuzz_cmd.replace('FIZZ', f'{i}')
                    curResult = guess_string(cur_wfuzz_cmd)
                    if curResult == "":
                        print('\nGuessed:\n')
                        for result in range(len(results)):
                            print(f"{result} :      {results[result]}")
                        exit(0)
                    else:
                        results.append(curResult)
                        i+=1

            else:
                guess_string(wfuzz_cmd)
            
        else:
            os.system(wfuzz_cmd)